# 자바 코딩테스트 관련 이론 지식 정리
- [원시 자료형 vs 참조 자료형](#원시-자료형-vs-참조-자료형)
  - [속도 비교](#속도-비교)
  - [각 언어별 지원 자료형(C, 파이썬, 자바, 코틀린)](#각-언어별-지원-자료형)
- [자바 컬렉션 프레임워크](#자바-컬렉션-프레임워크)
  - [초기 자료형의 성능 문제](#초기-자료형의-성능-문제)
  - [무한대의 크기를 저장할 수 있는 BigInteger](#biginteger)
- [시간복잡도 계산하기](#시간-복잡도)
  - [자바 컬렉션 프레임워크의 시간복잡도](#자바-컬렉션-프레임워크의-시간-복잡도)


## 원시 자료형 vs 참조 자료형
자바의 자료형은 크게 **원시 자료형과 참조 자료형으로 나눌 수 있다.** 원시 자료형은 C언어에서 다룬
자료형과 매우 유사하며, 이름 또한 익숙하다.

![img.png](images/4-1.png)
> int형 4byte에서 2^31-1까지 표현할 수 있는 이유는 32비트(4바이트)에서 맨 앞 1비트를 부호 표시용으로
> 사용하기 때문에 값을 표현하는 데에는 31비트 밖에 사용하지 못하기 때문이다. 다른 자료형도 원리는 같다.

**원시 자료형의 경우, 타입별로 고정된 크기의 메모리를 할당받는다.** `int a = 7`일 경우, 메모리 특정 영역에
4바이트를 할당하고, 거기엔 `00000000 00000000 00000000 00000111`이라는 이진수 값이 채워진다.

**참조 자료형의 경우, 원시 자료형과는 사뭇 다른 특징들을 갖고 있다.**
1. 참조 자료형은 원시 자료형에 비해 **메모리 모델에서 속도가 느린 영역에 할당된다.**
   (참조 자료형은 메모리에 주소 값이 저장되기 때문에 실제 값을 참조하기 위해서는 두 번 이동을 해야하는 꼴이므로 당연히 원시 자료형보다 느릴 것이다.)
2. 참조 자료형은 원시 자료형에 비해 일정한 크기의 메모리를 할당받는다. **원시 자료형의 경우, 각 타입별로
할당받는 메모리 크기가 제각각이다. 하지만 참조 자료형은 어떠한 값을 할당하더라도 고정된 크기의 메모리를 갖게 되는데
이는 원시 자료형보다 훨씬 크다. (대부분 16바이트를 할당받는다.)** 
3. 참조 자료형은 다양한 메소드를 갖고 있기에 이들을 활용하여 여러 편리한 작업을 수행할 수 있다.
4. 참조 자료형은 Null 값을 가질 수 있다. (원시 자료형은 값이 항상 존재해야 한다. `char`처럼 공백이라도 가져야 한다.)
5. 컬렉션에 저장될 수 있는 요소는 **반드시 참조 자료형만 가능하다.**
  - 컬렉션 프레임웤 설계 당시, **단순 값만 저장하는 것이 아니라 객체를 저장하는 것이 주된 디자인이었다.**
객체의 `equals()` 같은 기능들을 활용하여 설계되었기에 단순히 값만 저장하는 원시 자료형은 사용할 수 없다.
6. 원시 자료형을 선언하는 코드는 소문자로 시작하며, 참조 자료형은 대문자로 시작한다. (`int` vs `Integer`)

### 속도 비교
1억 개의 엘리멘트 중 맨 마지막 요소의 값을 조회하는 코드에 대한 성능 테스트를 진행했을 때,
`int[]`를 사용했을 경우, 삽입에 **128밀리초**, 조회에 **26밀리초**가 소요되었다.
반면에 `Integer[]`를 사용했을 경우, 삽입에 **847밀리초**, 조회에 **40밀리초**가 소요되었다.

코딩테스트에서는 원시 자료형과 참조 자료형을 상황에 맞게 적절히 사용할 줄 알아야 최적화 된 코드를
작성할 수 있다. 따라서 이들의 차이점을 간단하게라도 알고 가는 것이 중요하다!

참조 자료형은 원시 자료형에 비해 메모리 공간도 많이 차지한다는 점을 염두에 두어야한다.
특히, `boolean`의 경우, 1 바이트를 할당받지만 래퍼 클래스인 `Boolean`은 128 비트(16바이트)나
할당받게 되므로 훨씬 낭비됨을 알 수 있다.
> boolean이 1비트(0 또는 1만 표현)가 아니라 1바이트를 할당받는 이유 중 하나는 컴퓨터가 값을 표현하는 최소 단위가
> 바이트이기 때문이다.

### 각 언어별 지원 자료형
- C언어 : 원시 자료형
- 자바 : 원시 자료형, 참조 자료형
- 파이썬 : 참조 자료형
- 코틀린 : 참조 자료형

## 자바 컬렉션 프레임워크
코딩 테스트에서 주로 사용되는 컬렉션 프레임워크 인터페이스는 `List`, `Map`이다.
- List : `ArrayList` (`Vector` 사용 금지), `LinkedList` (Queue에 사용됨)
- Map : `HashMap`
- Deque(양방향 연결리스트) : `ArrayDeque` (Stack에 사용됨, `Stack` 사용 금지)

### 초기 자료형의 성능 문제
`Vector`, `Stack`과 같이 자바 초기 버전에 존재했던 구현 클래스를 사용하지 말도록 금지하고 있다.
이는 코딩테스트 뿐만 아니라 실무에서도 사용하지 않는다. 그 이유는 여러가지가 있겠지만 주된 이유는
`동기화` 때문이다. 먼저 해당 클래스들이 아직까지 존재하는 이유는 뭘까? 이는 자바가 구 버전과의 호환성을
중요시하기 때문에 삭제되지 않고 남아있는 것뿐이다.

자바 초기버전 당시에는 싱글코어 컴퓨터가 주류였다. 하지만 이제는 가정에서 보급되는 컴퓨터 조차도
멀티코어 컴퓨터가 대부분이다. 초기에 지원하던 자료형들은 바로 `동기화(Synchronized)`가 과도하게 적용되었기 때문에
무조건 하나의 스레드만 접근이 가능했다. 멀티 코어가 주류가 된 현시점에서 더이상 동기화를 강요할 수 없었고,
기존의 `HashTable`은 `HashMap`으로, `Vector`는 `ArrayList`로 대체되었다. 또한 모든 메서드가
동기화로 동작하는 `StringBuffer`도 `StringBuilder`로 대체되었다.

### BigInteger
`BigInteger` 자료형은 무제한 자릿수를 저장할 수 있다. 이는 저장되는 숫자(2진수)를
32비트씩 쪼갠 뒤에 이를 각각 10진수로 변환하여 각 배열에 저장한다. 따라서 무한할 정도로
큰 숫자를 더하고 연산을 진행할 수 있다. 다만 그만큼 연산 속도는 비교적 느리기에 무분별하게 사용해서는 안된다.

## 시간 복잡도
빅오 표기법은 복잡한 항들을 제거하고 최고차항만을 남겨서 알고리즘의 성능을 평가하는 방법이다.
만약 상수항의 값이 무시하지 못할 정도로 크다면 단순 빅오 표기법으로는 정확하게 파악할 수 없다.
하지만 빅오 표기법을 통해 데이터 개수가 무한히 증가할 때의 추이에 대한 상한선을 표기할 수 있다.

코드 상에서 시간 복잡도를 확인하는 방법은 각 로직의 `return`문 이전에 count 값을 증가시켜 보는 것이다.
그리고 이를 데이터의 개수와 비교하여 어떠한 관계를 갖는지 파악한다.

```java
public int factorial(int n) {
    if (n >= 1) {
        count++;
        return n * factorial(n-1);
    } else {
        count++;
        return 1;
    }
}

n = 5일 때, count = 6
n = 6일 때, count = 7
n = 7일 때, count = 8

따라서 O(n+1)이므로 빅오 표기법으로는 O(n) : 팩토리얼 재귀형태의 시간복잡도는 O(n)
```

### 자바 컬렉션 프레임워크의 시간 복잡도
1. `ArrayList` vs `LinkedList`
   - 인덱스 끝에 삽입 : O(1) or O(N) vs O(1)
   - 인덱스 중간에 삽입 : O(N) vs 탐색 : O(N), 삽입 : O(1)
   - 인덱스 끝에서 삭제 : O(1) vs O(1)
   - 인덱스 중간에서 삭제 : O(N) vs 탐색 : O(N), 삭제 : O(1)
   - 조회 : O(1) vs O(N)

`ArrayList`의 경우, 동적배열이므로 기본 용량이 다 찼을 때 새로운 배열을 복사하여 크기를 확장하는
`더블링`이 일어날 수 있다. 따라서 삽입 하는 과정에서 O(N)으로 될 수도 있다. 중간에 삽입하는 것도
마찬가지로 새로운 배열을 복사해야하기 때문에 O(N)이다.

`LinkedList`의 경우, 자료구조 특성상 삽입과 삭제가 수월하다. 그저 대상 노드의 포인터만 변경하면 되기 때문이다.
하지만 데이터를 삽입하는 연산에서는 **`LinkedList`가 `ArrayList`보다 오래 걸린다.**
그 이유는 `LinkedList`에서 노드를 삽입할 때, 추가적으로 Node 객체를 생성한는 데 비용이 발생하기 때문이다.
데이터가 적다면 상관없겠지만 대용량의 경우, 객체를 생성하는 비용을 무시할 수 없다.

반면에 데이터의 삭제 경우, `LinkedList`가 훨씬 빠르다. `ArrayList`는 구조 특성 상 삭제를 하면 빈 공간을
다시 채워줘야 하기 때문에 다시 복사하는 작업이 이루어진다. 반면에 `LinkedList`는 해당 노드만 제거하기 때문에 훨씬 빠르다.

정리 : `ArrayList`는 삽입과 조회가 빠르고, `LinkedList`는 인덱스 중간의 삽입과 삭제가 빠르다.

2. `HashMap` vs `LinkedHashMap`
    - 추가 : O(1) vs O(1)
    - 삭제 : O(1) vs O(1)
    - 조회 : O(1) vs O(1)

입력순서가 보장되는 `LinkedHashMap`은 `HashMap`보다 살짝 느린편이다. 하지만 속도 차이가 30% 내외로
사실상 동일하다고 봐도 된다.

3. `ArrayDeque` vs `LinkedList` (Deque 인터페이스를 구현한 LinkedList임)
    - 삽입 : O(1) vs O(1)
    - 추출 : O(1) vs O(1)

`ArrayDeque`는 `LinkedList`에 비해 삽입 속도가 8배 더 빠르다. `LinkedList`는 삽입 시에
별도의 노드를 생성하는 과정이 필요하기 때문에 비교적 느리다. 물로 삭제 시에는 별 차이가 없다.

정리 : `ArrayList`의 기능을 뛰어넘는 `ArrayList`와 `ArrayDeque`를 주로 활용하도록 하자.








